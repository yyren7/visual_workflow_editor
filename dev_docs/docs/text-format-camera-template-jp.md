# 二層構造カメラ制御翻訳システム

## System Prompt 設計

あなたは産業用カメラ制御の専門家です。ユーザーから受け取る簡潔な指示を、明確で段階的な操作手順に変換してください。

次のことを行ってください：

1. ユーザーの指示を解析し、必要な操作ステップを特定する
2. 専門用語を適切に使用しながら、各ステップを簡潔に説明する
3. 論理的かつ段階的な順序で手順をリスト化する
4. 各操作手順に対応する単一の SDK 関数と、その目的・パラメータを詳細に記載する

出力形式：

1. 「操作タイトル」: 処理内容を表す専門的なタイトル
2. 「概要」: 全体の処理を 1-2 文で簡潔に説明
3. 「操作手順」: 番号付きリストで、論理的な順序の操作ステップ
4. 「実行フロー」: 各操作ステップに対応する単一の SDK 関数とその詳細説明

実行フローの各ステップは以下の形式で記述してください：

- ステップ番号と説明
- 関数名と目的についての短い説明
- 関数の構文と主要パラメータの説明
- パラメータ選択の理由や注意点（必要な場合）

必要に応じて 1 つの操作手順に複数のサブステップを含める場合は、実行フローではそれぞれを個別の関数として記述してください。

## Template 設計

# {{操作タイトル}}

## 概要

{{1-2文の専門的かつ簡潔な説明}}

## 操作手順

1. {{最初のステップを専門用語を使いつつ簡潔に説明}}
2. {{2番目のステップを説明}}
3. {{3番目のステップを説明}}
   ...

## 実行フロー

### ステップ 1: {{最初のステップのタイトル}}

- 関数: `MV_CC_Initialize()`
- 目的: SDK システムを初期化し、後続の操作の準備をします
- パラメータ: なし
- 注意点: カメラ操作の最初に一度だけ呼び出す必要があります

### ステップ 2: {{2番目のステップのタイトル}}

- 関数: `MV_CC_EnumDevices(nTLayerType, pstDevList)`
- 目的: システムに接続されているカメラデバイスを検出します
- パラメータ:
  - `nTLayerType`: 検出するデバイスタイプ（1=GigE|USB3.0 デバイス）
  - `pstDevList`: 検出されたデバイス情報を格納する構造体ポインタ
- 注意点: 複数のカメラが接続されている場合、配列として結果が返されます

### ステップ 3: {{3番目のステップのタイトル}}

...

## 実際の応用例

# 単一フレーム取得と指定形式保存プロトコル

## ユーザー入力

カメラを起動し、一枚の画像を指定位置とフォーマットで保存する。

## 概要

工業用カメラを初期化して単一画像を取得し、指定された形式で保存するための標準操作手順です。

## 操作手順

1. カメラ SDK を初期化します
2. システムに接続されているカメラデバイスを検出します
3. 使用するカメラデバイスを選択します
4. 選択したカメラのハンドルを作成します
5. カメラデバイスへの接続を確立します
6. 画像フォーマットを設定します
7. 露出モードを手動に設定します
8. 露出時間を適切な値に設定します
9. ゲイン値を設定します
10. 画像取得処理を開始します
11. 1 フレームの画像を取得します
12. 必要に応じて画像のピクセル形式を変換します
13. 画像を指定した形式でファイルに保存します
14. 画像取得処理を停止します
15. カメラ接続を閉じます
16. カメラハンドルを破棄します
17. SDK を終了します

## 実行フロー

### ステップ 1: SDK の初期化

- 関数: `MV_CC_Initialize()`
- 目的: カメラ制御 SDK を初期化し、後続の操作の準備をします
- パラメータ: なし
- 注意点: デバイスを使用する前に必ず呼び出す必要があります

### ステップ 2: カメラデバイスの検出

- 関数: `MV_CC_EnumDevices(nTLayerType, pstDevList)`
- 目的: システムに接続されているカメラデバイスを検出します
- パラメータ:
  - `nTLayerType`: 検出するデバイスタイプ（MV_GIGE_DEVICE | MV_USB_DEVICE）
  - `pstDevList`: 検出されたデバイス情報を格納する構造体ポインタ
- 注意点: 複数のカメラが接続されている場合、配列として結果が返されます

### ステップ 3: カメラデバイスの選択

- 操作: `stDevInfo = pstDevList->pDeviceInfo[0]`
- 目的: 検出されたデバイスリストから使用するカメラを選択します
- 注意点: インデックス 0 は最初に検出されたカメラを意味します

### ステップ 4: カメラハンドルの作成

- 関数: `MV_CC_CreateHandle(&handle, &stDevInfo)`
- 目的: 選択したカメラデバイスのハンドルを作成します
- パラメータ:
  - `handle`: カメラハンドルを受け取るポインタ
  - `stDevInfo`: 選択したカメラデバイスの情報
- 注意点: このハンドルは以降のすべての操作で使用されます

### ステップ 5: カメラデバイスへの接続確立

- 関数: `MV_CC_OpenDevice(handle, nAccessMode, nSwitchoverKey)`
- 目的: カメラデバイスをオープンし、操作可能な状態にします
- パラメータ:
  - `handle`: カメラハンドル
  - `nAccessMode`: アクセスモード（1=排他的アクセス）
  - `nSwitchoverKey`: 切り替えキー（通常は 0）
- 注意点: 接続に失敗した場合、エラーコードが返されます

### ステップ 6: 画像フォーマットの設定

- 関数: `MV_CC_SetEnumValue(handle, "PixelFormat", PixelType_Gvsp_RGB8_Packed)`
- 目的: カメラの出力画像形式を RGB8 形式に設定します
- パラメータ:
  - `handle`: カメラハンドル
  - `"PixelFormat"`: 設定するパラメータ名
  - `PixelType_Gvsp_RGB8_Packed`: RGB8 ピクセル形式の値
- 注意点: カメラによってサポートされる形式が異なる場合があります

### ステップ 7: 露出モードの設定

- 関数: `MV_CC_SetEnumValue(handle, "ExposureAuto", 0)`
- 目的: 露出モードを手動（オフ）に設定します
- パラメータ:
  - `handle`: カメラハンドル
  - `"ExposureAuto"`: 設定するパラメータ名
  - `0`: 自動露出オフ（手動モード）
- 注意点: 0=オフ、1=連続自動露出、2=ワンショット自動露出

### ステップ 8: 露出時間の設定

- 関数: `MV_CC_SetFloatValue(handle, "ExposureTime", 20000)`
- 目的: 手動露出時間を 20 ミリ秒に設定します
- パラメータ:
  - `handle`: カメラハンドル
  - `"ExposureTime"`: 設定するパラメータ名
  - `20000`: 露出時間（マイクロ秒単位、20000=20ms）
- 注意点: 値はカメラの対応範囲内である必要があります

### ステップ 9: ゲイン値の設定

- 関数: `MV_CC_SetFloatValue(handle, "Gain", 10.0)`
- 目的: 画像センサーのゲイン値を設定します
- パラメータ:
  - `handle`: カメラハンドル
  - `"Gain"`: 設定するパラメータ名
  - `10.0`: ゲイン値（dB 単位）
- 注意点: 高いゲイン値はノイズを増加させる可能性があります

### ステップ 10: 画像取得処理の開始

- 関数: `MV_CC_StartGrabbing(handle)`
- 目的: カメラの画像取得処理を開始します
- パラメータ:
  - `handle`: カメラハンドル
- 注意点: この関数の後に画像データを取得できるようになります

### ステップ 11: 1 フレームの画像取得

- 関数: `MV_CC_GetOneFrameTimeout(handle, pData, nDataSize, &stFrameInfo, nMsec)`
- 目的: 指定したタイムアウト時間内にカメラから 1 フレームの画像を取得します
- パラメータ:
  - `handle`: カメラハンドル
  - `pData`: 画像データを格納するバッファ
  - `nDataSize`: バッファサイズ
  - `stFrameInfo`: フレーム情報を格納する構造体
  - `nMsec`: タイムアウト時間（ミリ秒、例：1000=1 秒）
- 注意点: タイムアウト時間内に画像が取得できない場合はエラーが返されます

### ステップ 12: 画像のピクセル形式変換

- 関数: `MV_CC_ConvertPixelType(handle, &stConvertParam)`
- 目的: 取得した画像のピクセル形式を必要な形式に変換します
- パラメータ:
  - `handle`: カメラハンドル
  - `stConvertParam`: 変換パラメータを格納する構造体
- 注意点: 元の形式と変換後の形式を適切に指定する必要があります

### ステップ 13: 画像ファイルへの保存

- 関数: `MV_CC_SaveImageToFile(handle, &stSaveParam)`
- 目的: 画像データを指定した形式でファイルに保存します
- パラメータ:
  - `handle`: カメラハンドル
  - `stSaveParam`: 保存パラメータを格納する構造体（ファイル名、形式など）
- 注意点: 保存形式には BMP、JPEG、PNG、TIFF などが指定可能です

### ステップ 14: 画像取得処理の停止

- 関数: `MV_CC_StopGrabbing(handle)`
- 目的: カメラの画像取得処理を停止します
- パラメータ:
  - `handle`: カメラハンドル
- 注意点: 取得処理を適切に終了するために必要です

### ステップ 15: カメラ接続の終了

- 関数: `MV_CC_CloseDevice(handle)`
- 目的: オープンしたカメラデバイスを閉じ、リソースを解放します
- パラメータ:
  - `handle`: カメラハンドル
- 注意点: カメラデバイスとの通信を適切に終了するために必要です

### ステップ 16: カメラハンドルの破棄

- 関数: `MV_CC_DestroyHandle(handle)`
- 目的: 作成したカメラハンドルを破棄し、関連リソースを解放します
- パラメータ:
  - `handle`: カメラハンドル
- 注意点: メモリリークを防ぐために必要です

### ステップ 17: SDK の終了処理

- 関数: `MV_CC_Finalize()`
- 目的: カメラ制御 SDK の使用を終了し、関連リソースを解放します
- パラメータ: なし
- 注意点: プログラム終了時に呼び出すべき SDK 終了関数です
