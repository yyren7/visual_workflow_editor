# ロボットプロセス生成プロンプト - ステージ 2：詳細プロセス記述からモジュールステップへ

## 目的

- このプロンプトは、「詳細プロセス記述計画」（前のステージで生成）から**単一のメインプロセス**または**単一のサブプロセス**記述を、特定の実行可能なロボットプログラムモジュールステップ（通常は XML 形式または同様の Blockly エクスポートされた構造化形式）に変換することを目的としています。
- 目標は、提供された**単一の**詳細なテキストプロセス計画を、特定の指示、ポイント、パラメータ、および制御ロジックを含むロボット操作シーケンスに正確にマッピングすることです。
- **重要な特徴：このプロンプトは並行処理用に設計されています。呼び出されるたびに、入力として提供された 1 つのメインプロセス記述または 1 つのサブプロセス記述に対してのみモジュールステップを生成します。**

## 入力資料

1.  **単一のメインプロセスまたは単一のサブプロセスの詳細プロセス記述計画（テキスト/Markdown）**：そのメインプログラムまたはサブプログラムの機能、コアロジックステップ、インタラクションポイントなどの詳細なテキスト記述が含まれています。

## 生成ガイドラインと要件

提供された「詳細プロセス記述計画」に基づいて特定のモジュールステップを生成するには、以下のガイドラインに従ってください。

### 1. 記述的ステップを特定の指示に変換する

- **アクション指示マッピング**：記述内の「移動」、「把持」、「配置」、「クランプを開く」、「クランプを閉じる」、「信号を待つ」などの操作を、ロボットの指示セット内の特定の指示（例：`moveP`、`set_output`、`wait_input`、`procedures_callnoreturn`）に正確にマッピングします。
- **ポイント定義と使用法**：記述で言及されている主要な場所（待機ポイント、アプローチポイント、精密な把持/配置ポイント、出発ポイント、安全ポイントなど）に特定のポイントコード（例：`P1`、`P21`、`P22`、`P23`）を割り当て、これらのポイントを`moveP`およびその他の指示で正しく使用します。サブプログラム内およびメインプログラム内でのポイントの一貫性と論理性を確保します。
- **パラメータ設定**：
  - **速度**：記述で言及されている精度要件（例：「精密移動」、「低速」）に基づいて、適切なタイミングでロボットの速度を調整するために`set_speed`指示を使用します（例：精密操作の前に速度を落とし、完了後に通常の速度に戻します）。
  - **I/O ピン**：クランプ制御（`set_output`）、センサーフィードバック（`wait_input`）、および外部デバイスインタラクション（`wait_external_io_input`、`set_external_io_output_during`）に特定の I/O 番号とピン番号を指定します。
  - **変数**：プロセス制御で使用される変数（例：ループカウンター、`controls_if`条件内の変数）に明確な名前と初期値を割り当てます（`set_number`）。
  - **タイマー**：操作遅延（`wait_timer`）のタイマー変数と遅延時間を指定します。

### 2. メインプログラムとサブプログラムの構造を構築する

入力がメインプロセス記述かサブプロセス記述かに基づいて、対応する構造を構築してください。

- **入力がメインプロセス記述の場合、メインプログラム構造を生成します**：
  - **初期化ブロック**：`select_robot`、`set_motor`、`set_number`（変数を初期化）などの指示で開始します。
  - **制御フローブロック**：`loop`を使用してメインループを実装し、`controls_if`を使用して条件付き実行ロジックを実装します。
  - **サブプログラム呼び出し**：`procedures_callnoreturn`を使用して、詳細記述計画で計画されたサブプログラムを順次呼び出します。
  - **移行と安全移動**：サブプログラム呼び出しの間または主要なステップの後に、`moveP`指示を挿入して安全ポイントまたは移行ポイントに移動します。
  - **同期とインタラクションブロック**：記述に基づいて、`wait_input`、`wait_external_io_input`、`wait_block`、`set_output`、`set_external_io_output_during`などのブロックを挿入し、それらのパラメータ（ピン、状態、条件）を正しく構成します。
  - **終了ブロック**：`return`ブロックでメインプログラムロジックを終了します。
- **入力がサブプロセス記述の場合、サブプログラム構造を生成します**：
  - **定義ブロック**：サブプログラムは`procedures_defnoreturn`で始まり、その名前が含まれます。
  - **操作シーケンス**：記述計画で定義された機能を実装するために、`moveP`、`procedures_callnoreturn`（クランプ制御などの他のアトミックサブプログラムの呼び出し）、`set_speed`、`wait_timer`などの一連の指示を内部に含みます。
  - **パラメータ化された呼び出し**：サブプログラム内のクランプなどの共有モジュールへの呼び出しが正しいことを確認します。
  - **終了ブロック**：サブプログラムは通常`return`で終了するか、単に実行を完了します。

### 3. モジュール化と再利用を実装する

- **アトミック操作カプセル化**：クランプの開閉などは、独立したパラメータ化されたサブプログラム（例：`Open_BH_Crump`、`Close_BRG&PLT_Crump`）として実装し、他のサブプログラムで`procedures_callnoreturn`を介して呼び出す必要があります。
- **標準化された移動シーケンス**：材料の把持/配置については、記述の「アプローチポイント -> 精密ポイント -> アクション実行 -> 出発ポイント -> 安全ポイント」パターンに厳密に従い、それを特定の`moveP`指示シーケンスに変換します。

### 4. 特殊ケース処理

- **無効ブロック（`disabled="true"`）**：記述計画で言及されている「オプション/無効ロジック」またはデバッグ中に一時的に実行しないステップ（特に外部 IO インタラクション）については、対応する生成されたブロックに`disabled="true"`属性を追加します。
- **エラー処理**：記述計画でエラー処理ロジックが言及されている場合は、対応する条件判断と代替パスステップに変換する必要があります。（この例では詳細に説明されていませんが、実際のアプリケーションでは考慮する必要があります）。

要約すると、提供された**単一の**詳細なテキストプロセス計画（それがメインプロセスであろうとサブプロセスであろうと）を、ロボットが解釈して実行できる構造化されたステップのリストに正確に翻訳し、すべてのアクション、パラメータ、ポイント、制御フロー、およびモジュール呼び出しが正しく反映されるようにする必要があります。

## Fewshot の例

**注意：以下の fewshot の例は、複雑なビジネス記述から完全なモジュールステップへの変換プロセスを包括的に示すために、メインプロセスと複数のサブプロセスを含む完全なタスク記述と、それらに対応するすべてのモジュールステップを提供します。このプロンプトへの実際の同時呼び出しでは、入力は分解された単一のメインプロセス記述または単一のサブプロセス記述になり、出力もその単一のプロセスに対応するモジュールステップになります。**

### タスク入力の例（詳細プロセス記述計画）

サブプログラムとその機能記述

1.  **`BRG_Get_BRG`（ベアリング取得）**：

    - 機能：ロボットは指定された場所（例：材料ラック）からベアリングを取得します。
    - コアロジック：ベアリング待機ポイントに移動 -> ベアリング上部に移動 -> ベアリングクランプを開く -> ベアリング精密把持ポイントに下降 -> ベアリングクランプを閉じる -> 上昇 -> 出発ポイントに移動 -> 安全/初期ポイントに戻る。
    - 関与するクランプ：`BRG&PLT_Crump`（ベアリングとパレットを操作するためのクランプ）。

2.  **`CNV_Get_BH`（コンベアからベアリングハウジング取得）**：

    - 機能：ロボットはコンベアの指定された場所からベアリングハウジングを取得します。
    - コアロジック：コンベア付近のベアリングハウジング待機ポイントに移動 -> ベアリングハウジング上部に移動 -> ベアリングハウジングクランプを開く -> ベアリングハウジング精密把持ポイントに下降 -> ベアリングハウジングクランプを閉じる -> 上昇 -> 安全/初期ポイントに戻る。
    - 関与するクランプ：`BH_Crump`（ベアリングハウジングを操作するためのクランプ）。

3.  **`RMC_Put_BH&BRG`（ベアリングハウジングとベアリングを右マシニングセンターに配置）**：

    - 機能：ロボットは以前に取得したベアリングハウジングとベアリングを右マシニングセンター（RMC）の指定されたステーションに順次配置します。
    - コアロジック：
      - RMC 待機ポイントに移動。
      - ベアリングハウジング配置：RMC ベアリングハウジング配置ポイントの上部に移動 -> 配置ポイントに正確に移動 -> ベアリングハウジングクランプを開く -> 上昇。
      - ベアリング配置：RMC ベアリング配置ポイントの上部に移動 -> 配置ポイントに正確に移動 -> ベアリングクランプを開く -> 上昇。
      - RMC 出発ポイントに移動。
    - 関与するクランプ：`BH_Crump`、`BRG&PLT_Crump`。
    - 注意：精度を確保するために、配置中に速度を下げる必要がある場合があります。

4.  **`RMC_Get_BH`（右マシニングセンターから組み立て済み部品取得）**：

    - 機能：ロボットは右マシニングセンター（RMC）から組み立て済み（または処理済み）のベアリングハウジングを取得します（この時点で、ベアリングと組み立て済みである可能性があります）。
    - コアロジック：RMC 待機ポイントに移動 -> 組み立て済み部品の上部に移動 -> ベアリングハウジングクランプを開く（以前に開いていた場合は、このステップは把持の準備です） -> 精密把持ポイントに下降 -> ベアリングハウジングクランプを閉じる -> 上昇 -> 出発ポイントに移動。
    - 関与するクランプ：`BH_Crump`。

5.  **`LMC_Put_BH`（部品を左マシニングセンターに配置）**：

    - 機能：ロボットは RMC から取得した部品を左マシニングセンター（LMC）に配置して、一時保管または後続処理を行います。
    - コアロジック：LMC 待機ポイントに移動 -> LMC 配置ポイントの上部に移動 -> 配置ポイントに正確に移動 -> ベアリングハウジングクランプを開く -> 上昇 -> 安全/初期ポイントに戻る。
    - 関与するクランプ：`BH_Crump`。

6.  **`CNV_Get_PLT`（コンベアからパレット取得）**：

    - 機能：ロボットは指定された場所（おそらくコンベアの別の領域）から空のパレットを取得します。
    - コアロジック：パレット待機ポイントに移動 -> パレット上部に移動 -> （おそらく低速で）把持ポイントに正確に移動 -> パレットクランプを閉じる -> 上昇 -> 安全/初期ポイントに戻る。
    - 関与するクランプ：`BRG&PLT_Crump`。

7.  **`CNV_Put_PLT`（パレットをコンベアに配置）**：

    - 機能：ロボットは取得した空のパレットをコンベアの指定されたステーションに配置します。
    - コアロジック：コンベアパレット配置ポイントの上部に移動 -> 配置ポイントに正確に移動 -> パレットクランプを開く -> 上昇 -> 安全/初期ポイントに戻る。
    - 関与するクランプ：`BRG&PLT_Crump`。

8.  **`LMC_Get_BH`（左マシニングセンターから部品取得）**：

    - 機能：ロボットは左マシニングセンター（LMC）から以前に保管されていた部品を取得します。
    - コアロジック：LMC 待機ポイントに移動 -> 部品上部に移動 -> 把持ポイントに正確に移動 -> ベアリングハウジングクランプを閉じる -> 上昇 -> 安全/初期ポイントに戻る。
    - 関与するクランプ：`BH_Crump`。

9.  **`CNV_Put_BH`（部品をコンベアのパレットに配置）**：

    - 機能：ロボットは LMC から取得した部品を、コンベア上の事前に配置されたパレットに正確に配置します。
    - コアロジック：コンベアパレット（積載部品あり）の上部に移動 -> パレット内の指定された配置ポイントに正確に移動 -> ベアリングハウジングクランプを開く -> 上昇 -> 安全/初期ポイントに戻る。
    - 関与するクランプ：`BH_Crump`。

10. **`Open_BH_Crump`（ベアリングハウジングクランプを開く）**：

    - 機能：ロボットのエンドエフェクタを制御して、ベアリングハウジングを保持するために使用されるクランプを開きます。
    - コアロジック：開信号を送信し、クランプが所定の位置にあることのフィードバックを待ちます。

11. **`Close_BH_Crump`（ベアリングハウジングクランプを閉じる）**：

    - 機能：ロボットのエンドエフェクタを制御して、ベアリングハウジングを保持するために使用されるクランプを閉じます。
    - コアロジック：閉信号を送信し、クランプが所定の位置にあることのフィードバックを待ちます。

12. **`Open_BRG&PLT_Crump`（ベアリング/パレットクランプを開く）**：

    - 機能：ロボットのエンドエフェクタを制御して、ベアリングまたはパレットを保持するために使用されるクランプを開きます。
    - コアロジック：開信号を送信し、クランプが所定の位置にあることのフィードバックを待ちます。

13. **`Close_BRG&PLT_Crump`（ベアリング/パレットクランプを閉じる）**：
    - 機能：ロボットのエンドエフェクタを制御して、ベアリングまたはパレットを保持するために使用されるクランプを閉じます。
    - コアロジック：閉信号を送信し、クランプが所定の位置にあることのフィードバックを待ちます。

メインプログラムプロセス記述

ロボットモデルを選択します（例：「dobot*mg400」）。
ロボットモーターを起動します。
必要なプロセス制御変数を初期化します（例：`N5 = 2`、例の条件判断に使用）。
メインループが開始します。
ループ条件：特定の条件または無限ループに基づく場合があります（この例では、`N5 == 2`に基づいてコアプロセスを 1 回実行します）。
ロボットは**初期/安全ポイント（例：「P1」）**に移動します。
*（オプション/無効ロジック）_外部開始信号を待ちます（例：外部 IO 入力）。
サブプログラム`BRG_Get_BRG`（ベアリング取得）を呼び出します。
_（オプション/無効ロジック）_材料が所定の位置にあるか、ステーションがクリアになる信号を待ちます。
サブプログラム`CNV_Get_BH`（コンベアからベアリングハウジング取得）を呼び出します。
ロボットは**初期/安全ポイント（例：「P1」）**に移動します。
マシニングセンター（RMC）の準備ができている信号を待ちます。
サブプログラム`RMC_Put_BH&BRG`（ベアリングハウジングとベアリングを RMC に配置）を呼び出します。
RMC 加工完了信号を待ちます。
部品が取り出されたか、取り出す準備ができたことを RMC に通知する信号を送信します。
RMC 確認信号を待ちます。
サブプログラム`RMC_Get_BH`（RMC から組み立て済み部品取得）を呼び出します。
ロボットは**初期/安全ポイント（例：「P1」）**に移動します。
サブプログラム`LMC_Put_BH`（部品を LMC に配置）を呼び出します。
ロボットは**初期/安全ポイント（例：「P1」）**に移動します。
サブプログラム`CNV_Get_PLT`（コンベアからパレット取得）を呼び出します。
サブプログラム`CNV_Put_PLT`（パレットをコンベアに配置）を呼び出します。
ロボットは**初期/安全ポイント（例：「P1」）**に移動します。
サブプログラム`LMC_Get_BH`（LMC から部品取得）を呼び出します。
ロボットは**初期/安全ポイント（例：「P1」）**に移動します。
サブプログラム`CNV_Put_BH`（部品をコンベアのパレットに配置）を呼び出します。
_（オプション/無効ロジック）\*タスク完了信号を外部システムに送信します。
メインループが終了します。

#### III. モジュール化と再利用の説明

- **クランプ操作**：`Open/Close_BH_Crump`および`Open/Close_BRG&PLT_Crump`は、さまざまな材料ピックアンドプレースサブプログラムで呼び出される標準のクランプ制御サブプログラムです。
- **移動シーケンス**：ほとんどのピック/プレースサブプログラムは、「待機ポイント -> 接近ポイント -> 精密ポイント -> （アクション実行）-> リフトポイント -> 出発ポイント -> 安全ポイント」の移動ロジックに従います。
- **速度制御**：`RMC_Put_BH&BRG`、`CNV_Get_PLT`などの精密操作では、記述に低速移動フェーズの計画について言及する必要があります。
- **外部インタラクション**：メインプロセスは、プロセス同期のために外部デバイス（RMC、LMC、コンベアセンサー）との複数の信号インタラクションポイントを計画します。デバッグ中に不確実または無効にできるインタラクションは、オプション/無効としてマークされます。

### 生成思考プロセスの例（概要）

上記の説明的なメインプロセスとサブプロセスをモジュールステップに変換する場合、主に以下のマッピング関係に従います。

- **メインプログラム記述の初期化** -> `select_robot`、`set_motor`、`set_number`ブロック。
- **メインプログラム記述のループ/条件** -> `loop`、`controls_if`ブロック。
- **メインプログラムおよびサブプログラム記述の「サブプログラム X を呼び出す」** -> `procedures_callnoreturn`ブロック、そのパラメータはサブプログラム名 X です。
- **サブプログラム記述の「機能：...」および「コアロジック：...」** -> `procedures_defnoreturn`ブロック、そのパラメータはサブプログラム名であり、内部にコアロジックを実装する指示シーケンスが含まれます。
- **「Y ポイントに移動」** -> `moveP`ブロック、パラメータはポイント Y（例：「P1」、「P21」）です。ポイントは、コンテキストロジックに基づいて架空のものにするか、既存のライブラリから選択する必要があります。
- **「Z クランプを開く/閉じる」などのクランプ操作** -> 対応するクランプ制御サブプログラム（例：`Open_BH_Crump`）を呼び出します。これには、内部に`set_output`（クランプ制御）と`wait_input`（クランプセンサーフィードバック待機）が含まれます。
- **「X 信号を待つ」** -> `wait_input`（ロボット内部信号）または`wait_external_io_input`（外部デバイス IO 信号）または`wait_block`（複合条件）。
- **「ロボットの速度を低速/通常速度に設定」** -> `set_speed`ブロック、パラメータは速度パーセンテージです。
- **「オプション/無効ロジック」** -> 対応するブロックに`disabled="true"`を追加します。
- **「プロセス終了/復帰」** -> `return`ブロック。

### 出力の例（ロボット操作詳細プロセスステップインスタンス）

## メインプログラムステップの改良

1. **デフォルトのロボット（例：「dobot_mg400」）**を選択します（ブロックタイプ：`select_robot`）
2. **モーターを起動します（例：「on」）**（ブロックタイプ：`set_motor`）
3. **プロセス制御用の数値変数（例：「N5」）を初期判断値（例：2）に設定します**（ブロックタイプ：`set_number`）
4. ループを開始します - ループ内の操作：（ブロックタイプ：`loop`）
5. 条件判断 - IF 条件：**数値変数（例：「N5」）が初期設定値（例：2）と等しい** - DO（条件が真の場合）：（ブロックタイプ：`controls_if`）
6. PTP 移動で**初期/安全ポイント（例：「P1」）**に移動します（ブロックタイプ：`moveP`）
7. 外部 I/O 入力を待ちます（**I/O 番号を指定、ピンを指定、状態を指定（例：I/O 番号：1、ピン：「0」、状態：「on」）**）（ブロックタイプ：`wait_external_io_input`）（このブロックは無効です）
8. サブプログラム「BRG_Get_BRG」（ベアリング取得）を呼び出します（ブロックタイプ：`procedures_callnoreturn`）
9. 複合条件を待ちます - 条件：（**指定された複合外部 I/O 条件（例：（外部 I/O（I/O 番号 1）ピン「3」がブール値 True と等しい）AND（外部 I/O（I/O 番号 1）ピン「4」がブール値 True と等しい））**）（ブロックタイプ：`wait_block`）（このブロックは無効です）
10. サブプログラム「CNV_Get_BH」（コンベアからベアリングハウジング取得）を呼び出します（ブロックタイプ：`procedures_callnoreturn`）
11. PTP 移動で**初期/安全ポイント（例：「P1」）**に移動します（ブロックタイプ：`moveP`）
12. ロボットの**指定された入力ピンがプリセット状態（例：ピン「12」が「on」）になるのを待ちます**（ブロックタイプ：`wait_input`）
13. サブプログラム「RMC_Put_BH&BRG」（ベアリングハウジングとベアリングを右マシニングセンター/ステーションに配置）を呼び出します（ブロックタイプ：`procedures_callnoreturn`）
14. ロボットの**指定された入力ピンがプリセット状態（例：ピン「12」が「off」）になるのを待ちます**（ブロックタイプ：`wait_input`）
15. ロボットの**指定された出力ピンをプリセット状態（例：ピン「6」が「on」）に設定します**（ブロックタイプ：`set_output`）
16. 複合条件を待ちます - 条件：（**指定されたロボット複合 I/O 条件（例：（ロボット I/O ピン「10」がブール値 True と等しい）OR（ロボット I/O ピン「11」がブール値 True と等しい））**）（ブロックタイプ：`wait_block`）
17. サブプログラム「RMC_Get_BH」（右マシニングセンター/ステーションからベアリングハウジング取得）を呼び出します（ブロックタイプ：`procedures_callnoreturn`）
18. PTP 移動で**初期/安全ポイント（例：「P1」）**に移動します（ブロックタイプ：`moveP`）
19. サブプログラム「LMC_Put_BH」（ベアリングハウジングを左マシニングセンター/ステーションに配置）を呼び出します（ブロックタイプ：`procedures_callnoreturn`）
20. PTP 移動で**初期/安全ポイント（例：「P1」）**に移動します（ブロックタイプ：`moveP`）
21. サブプログラム「CNV_Get_PLT」（コンベアからパレット取得）を呼び出します（ブロックタイプ：`procedures_callnoreturn`）
22. サブプログラム「CNV_Put_PLT」（パレットをコンベアに配置）を呼び出します（ブロックタイプ：`procedures_callnoreturn`）
23. PTP 移動で**初期/安全ポイント（例：「P1」）**に移動します（ブロックタイプ：`moveP`）
24. サブプログラム「LMC_Get_BH」（左マシニングセンター/ステーションからベアリングハウジング取得）を呼び出します（ブロックタイプ：`procedures_callnoreturn`）
25. PTP 移動で**初期/安全ポイント（例：「P1」）**に移動します（ブロックタイプ：`moveP`）
26. サブプログラム「CNV_Put_BH」（ベアリングハウジングをコンベアに配置）を呼び出します（ブロックタイプ：`procedures_callnoreturn`）
27. **指定されたタイマー変数（例：「N483」）**の間、外部 I/O 出力を設定します（**I/O 番号を指定、ピンを指定、状態を指定**（例：I/O 番号：1、ピン：「3」、状態：「on」））（ブロックタイプ：`set_external_io_output_during`）（このブロックは無効です）
28. 戻ります（ブロックタイプ：`return`）

## サブプログラムステップの改良

1.1. **サブプログラム「BRG_Get_BRG」（ベアリング取得）を定義します**（ブロックタイプ：`procedures_defnoreturn`）
1.2. PTP 移動で**ベアリング把持エリアの待機ポイント（例：「P21」）**に移動します（ブロックタイプ：`moveP`）
1.3. PTP 移動で**ベアリング上部のアプローチポイント（例：「P22」）**に移動します（ブロックタイプ：`moveP`）
1.4. サブプログラム「Open_BRG&PLT_Crump」（ベアリングおよびパレット/ボード操作用クランプを開く）を呼び出します（ブロックタイプ：`procedures_callnoreturn`）
1.5. PTP 移動で**ベアリングの精密把持ポイント（例：「P23」）**に移動します（ブロックタイプ：`moveP`）
1.6. サブプログラム「Close_BRG&PLT_Crump」（ベアリングおよびパレット/ボード操作用クランプを閉じる）を呼び出します（ブロックタイプ：`procedures_callnoreturn`）
1.7. PTP 移動で**ベアリング把持後のリフトポイント（例：「P25」）**に移動します（ブロックタイプ：`moveP`）
1.8. PTP 移動で**ベアリング把持後の出発ポイント（例：「P26」）**に移動します（ブロックタイプ：`moveP`）
1.9. PTP 移動で**ベアリング把持プロセスの終了/復帰ポイント（例：「P21」）**に移動します（ブロックタイプ：`moveP`）

2.1. **サブプログラム「Open_BH_Crump」（ベアリングハウジングクランプを開く）を定義します**（ブロックタイプ：`procedures_defnoreturn`）
2.2. **指定されたタイマー変数（例：「N483」、操作遅延用）**を待ちます（ブロックタイプ：`wait_timer`）
2.3. ロボットの**クランプ制御出力ピン（例：ピン「1」）を開状態（例：「on」）に設定します**（ブロックタイプ：`set_output`）
2.4. ロボットの**クランプ状態フィードバック入力ピン（例：ピン「0」）が開完了状態（例：「on」）になるのを待ちます**（ブロックタイプ：`wait_input`）

3.1. **サブプログラム「CNV_Get_BH」（コンベアからベアリングハウジング取得）を定義します**（ブロックタイプ：`procedures_defnoreturn`）
3.2. PTP 移動で**コンベア付近のベアリングハウジング把持の待機ポイント（例：「P31」）**に移動します（ブロックタイプ：`moveP`）
3.3. PTP 移動で**コンベア上のベアリングハウジング上部のアプローチポイント（例：「P32」）**に移動します（ブロックタイプ：`moveP`）
3.4. サブプログラム「Open_BH_Crump」（ベアリングハウジングクランプを開く）を呼び出します（ブロックタイプ：`procedures_callnoreturn`）
3.5. PTP 移動で**コンベア上のベアリングハウジングの精密把持ポイント（例：「P33」）**に移動します（ブロックタイプ：`moveP`）
3.6. サブプログラム「Close_BH_Crump」（ベアリングハウジングクランプを閉じる）を呼び出します（ブロックタイプ：`procedures_callnoreturn`）
3.7. PTP 移動で**コンベアベアリングハウジング把持後のリフトポイント（例：「P32」）**に移動します（ブロックタイプ：`moveP`）
3.8. PTP 移動で**コンベアベアリングハウジング把持プロセスの終了/復帰ポイント（例：「P31」）**に移動します（ブロックタイプ：`moveP`）

4.1. **サブプログラム「Close_BH_Crump」（ベアリングハウジングクランプを閉じる）を定義します**（ブロックタイプ：`procedures_defnoreturn`）
4.2. **指定されたタイマー変数（例：「N482」、操作遅延用）**を待ちます（ブロックタイプ：`wait_timer`）
4.3. ロボットの**クランプ制御出力ピン（例：ピン「1」）を閉状態（例：「off」）に設定します**（ブロックタイプ：`set_output`）
4.4. ロボットの**クランプ状態フィードバック入力ピン（例：ピン「1」）が閉完了状態（例：「on」）になるのを待ちます**（ブロックタイプ：`wait_input`）

5.1. **サブプログラム「Open_BRG&PLT_Crump」（ベアリングおよびパレット/ボード操作用クランプを開く）を定義します**（ブロックタイプ：`procedures_defnoreturn`）
5.2. **指定されたタイマー変数（例：「N482」、操作遅延用）**を待ちます（ブロックタイプ：`wait_timer`）
5.3. ロボットの**クランプ制御出力ピン（例：ピン「2」）を開状態（例：「on」）に設定します**（ブロックタイプ：`set_output`）
5.4. ロボットの**クランプ状態フィードバック入力ピン（例：ピン「2」）が開完了状態（例：「on」）になるのを待ちます**（ブロックタイプ：`wait_input`）

6.1. **サブプログラム「RMC_Put_BH&BRG」（ベアリングハウジングとベアリングを右マシニングセンター/ステーションに配置）を定義します**（ブロックタイプ：`procedures_defnoreturn`）
6.2. PTP 移動で**RMC（右マシニングセンター）配置操作の待機ポイント（例：「P20」）**に移動します（ブロックタイプ：`moveP`）
6.3. PTP 移動で**RMC ステーション付近のアプローチポイント（例：「P11」）**に移動します（ブロックタイプ：`moveP`）
6.4. PTP 移動で**RMC ベアリングハウジング配置場所の上方点（例：「P12」）**に移動します（ブロックタイプ：`moveP`）
6.5. PTP 移動で**RMC ベアリングハウジングの精密配置ポイント（例：「P14」）**に移動します（ブロックタイプ：`moveP`）
6.6. PTP 移動で**RMC ベアリングハウジング配置後の姿勢調整/リフトポイント（例：「P15」）**に移動します（ブロックタイプ：`moveP`）
6.7. サブプログラム「Open_BH_Crump」（ベアリングハウジングクランプを開く）を呼び出します（ブロックタイプ：`procedures_callnoreturn`）
6.8. ロボットの速度を**低速（例：10％、精密配置用）**に設定します（ブロックタイプ：`set_speed`）
6.9. PTP **精密移動**で**RMC ベアリングハウジングの配置ポイント（例：「P14」）**に移動します（ブロックタイプ：`moveP`）
6.10. ロボットの速度を**通常速度（例：100％）**に戻します（ブロックタイプ：`set_speed`）
6.11. PTP 移動で**RMC ベアリング配置場所の上方点（例：「P13」）**に移動します（ブロックタイプ：`moveP`）
6.12. PTP 移動で**RMC ベアリングの精密配置ポイント（例：「P16」）**に移動します（ブロックタイプ：`moveP`）
6.13. PTP 移動で**RMC ベアリング配置後の姿勢調整/リフトポイント（例：「P17」）**に移動します（ブロックタイプ：`moveP`）
6.14. サブプログラム「Open_BRG&PLT_Crump」（ベアリングおよびパレット/ボード操作用クランプを開く）を呼び出します（ブロックタイプ：`procedures_callnoreturn`）
6.15. ロボットの速度を**低速（例：10％、精密配置用）**に設定します（ブロックタイプ：`set_speed`）
6.16. PTP **精密移動**で**RMC ベアリングの配置ポイント（例：「P16」）**に移動します（ブロックタイプ：`moveP`）
6.17. ロボットの速度を**通常速度（例：100％）**に戻します（ブロックタイプ：`set_speed`）
6.18. PTP 移動で**RMC 配置操作完了後のリフトポイント（例：「P12」）**に移動します（ブロックタイプ：`moveP`）
6.19. PTP 移動で**RMC 配置操作完了後の出発ポイント（例：「P11」）**に移動します（ブロックタイプ：`moveP`）

7.1. **サブプログラム「Close_BRG&PLT_Crump」（ベアリングおよびパレット/ボード操作用クランプを閉じる）を定義します**（ブロックタイプ：`procedures_defnoreturn`）
7.2. **指定されたタイマー変数（例：「N482」、操作遅延用）**を待ちます（ブロックタイプ：`wait_timer`）
7.3. ロボットの**クランプ制御出力ピン（例：ピン「2」）を閉状態（例：「off」）に設定します**（ブロックタイプ：`set_output`）
7.4. ロボットの**クランプ状態フィードバック入力ピン（例：ピン「3」）が閉完了状態（例：「on」）になるのを待ちます**（ブロックタイプ：`wait_input`）

8.1. **サブプログラム「RMC_Get_BH」（右マシニングセンター/ステーションからベアリングハウジング取得）を定義します**（ブロックタイプ：`procedures_defnoreturn`）
8.2. PTP 移動で**RMC ステーション付近のアプローチポイント（例：「P11」）**に移動します（ブロックタイプ：`moveP`）
8.3. PTP 移動で**RMC 組み立て済み部品把持場所の上方点（例：「P12」）**に移動します（ブロックタイプ：`moveP`）
8.4. PTP 移動で**RMC 組み立て済み部品の精密把持ポイント（例：「P14」）**に移動します（ブロックタイプ：`moveP`）
8.5. PTP 移動で**RMC 組み立て済み部品把持後の姿勢調整ポイント（例：「P15」）**に移動します（ブロックタイプ：`moveP`）
8.6. サブプログラム「Close_BH_Crump」（ベアリングハウジングクランプを閉じる）を呼び出します（ブロックタイプ：`procedures_callnoreturn`）
8.7. PTP 移動で**RMC 組み立て済み部品把持後のリフトポイント（例：「P14」に戻ってからリフト、または直接「P12」へ）**に移動します（ブロックタイプ：`moveP`）
8.8. PTP 移動で**RMC 把持操作完了後の上昇点（例：「P12」）**に移動します（ブロックタイプ：`moveP`）
8.9. PTP 移動で**RMC 把持操作完了後の出発ポイント（例：「P11」）**に移動します（ブロックタイプ：`moveP`）
8.10. PTP 移動で**RMC 把持プロセスの終了/復帰ポイント（例：「P20」）**に移動します（ブロックタイプ：`moveP`）

9.1. **サブプログラム「LMC_Put_BH」（ベアリングハウジングを左マシニングセンター/ステーションに配置）を定義します**（ブロックタイプ：`procedures_defnoreturn`）
9.2. PTP 移動で**LMC（左マシニングセンター）配置操作の待機ポイント（例：「P41」）**に移動します（ブロックタイプ：`moveP`）
9.3. PTP 移動で**LMC ステーション上部のアプローチポイント（例：「P42」）**に移動します（ブロックタイプ：`moveP`）
9.4. PTP 移動で**LMC の精密配置ポイント（例：「P43」）**に移動します（ブロックタイプ：`moveP`）
9.5. サブプログラム「Open_BH_Crump」（ベアリングハウジングクランプを開く）を呼び出します（ブロックタイプ：`procedures_callnoreturn`）
9.6. PTP 移動で**LMC 配置後のリフトポイント（例：「P42」）**に移動します（ブロックタイプ：`moveP`）
9.7. PTP 移動で**LMC 配置後の出発ポイント（例：「P41」）**に移動します（ブロックタイプ：`moveP`）
9.8. PTP 移動で**初期/安全ポイント（例：「P1」）**に移動します（ブロックタイプ：`moveP`）

10.1. **サブプログラム「CNV_Get_PLT」（コンベアからパレット/ボード取得）を定義します**（ブロックタイプ：`procedures_defnoreturn`）
10.2. PTP 移動で**コンベア付近のパレット把持の待機ポイント（例：「P34」）**に移動します（ブロックタイプ：`moveP`）
10.3. PTP 移動で**コンベア上のパレット上部のアプローチポイント（例：「P35」）**に移動します（ブロックタイプ：`moveP`）
10.4. ロボットの速度を**低速（例：10％、精密把持用）**に設定します（ブロックタイプ：`set_speed`）
10.5. PTP **精密移動**で**コンベア上のパレットの把持ポイント（例：「P36」）**に移動します（ブロックタイプ：`moveP`）
10.6. サブプログラム「Close_BRG&PLT_Crump」（ベアリングおよびパレット/ボード操作用クランプを閉じる）を呼び出します（ブロックタイプ：`procedures_callnoreturn`）
10.7. PTP 移動で**コンベアパレット把持後のリフトポイント（例：「P35」）**に移動します（ブロックタイプ：`moveP`）
10.8. ロボットの速度を**通常速度（例：100％）**に戻します（ブロックタイプ：`set_speed`）
10.9. PTP 移動で**コンベアパレット把持プロセスの終了/復帰ポイント（例：「P34」）**に移動します（ブロックタイプ：`moveP`）

11.1. **サブプログラム「CNV_Put_PLT」（パレット/ボードをコンベアに配置）を定義します**（ブロックタイプ：`procedures_defnoreturn`）
11.2. PTP 移動で**コンベアパレット配置場所の上方点（例：「P37」）**に移動します（ブロックタイプ：`moveP`）
11.3. PTP 移動で**コンベアパレットの精密配置ポイント（例：「P38」）**に移動します（ブロックタイプ：`moveP`）
11.4. サブプログラム「Open_BRG&PLT_Crump」（ベアリングおよびパレット/ボード操作用クランプを開く）を呼び出します（ブロックタイプ：`procedures_callnoreturn`）
11.5. PTP 移動で**コンベアパレット配置後のリフトポイント（例：「P37」）**に移動します（ブロックタイプ：`moveP`）
11.6. PTP 移動で**コンベアパレット配置プロセスの終了/復帰ポイント（例：「P34」）**に移動します（ブロックタイプ：`moveP`）

12.1. **サブプログラム「LMC_Get_BH」（左マシニングセンター/ステーションからベアリングハウジング取得）を定義します**（ブロックタイプ：`procedures_defnoreturn`）
12.2. PTP 移動で**LMC 把持操作の待機ポイント（例：「P41」）**に移動します（ブロックタイプ：`moveP`）
12.3. PTP 移動で**LMC ステーション上部のアプローチポイント（例：「P42」）**に移動します（ブロックタイプ：`moveP`）
12.4. PTP 移動で**LMC の精密把持ポイント（例：「P43」）**に移動します（ブロックタイプ：`moveP`）
12.5. サブプログラム「Close_BH_Crump」（ベアリングハウジングクランプを閉じる）を呼び出します（ブロックタイプ：`procedures_callnoreturn`）
12.6. PTP 移動で**LMC 把持後のリフトポイント（例：「P42」）**に移動します（ブロックタイプ：`moveP`）
12.7. PTP 移動で**LMC 把持後の出発ポイント（例：「P41」）**に移動します（ブロックタイプ：`moveP`）

13.1. **サブプログラム「CNV_Put_BH」（ベアリングハウジングをコンベアに配置）を定義します**（ブロックタイプ：`procedures_defnoreturn`）
13.2. PTP 移動で**コンベア上の組み立て済み部品配置場所の上方点（例：「P39」）**に移動します（ブロックタイプ：`moveP`）
13.3. PTP 移動で**コンベア上の組み立て済み部品の精密配置ポイント（例：「P40」、パレット上を意味する）**に移動します（ブロックタイプ：`moveP`）
13.4. サブプログラム「Open_BH_Crump」（ベアリングハウジングクランプを開く）を呼び出します（ブロックタイプ：`procedures_callnoreturn`）
13.5. PTP 移動で**コンベア組み立て済み部品配置後のリフトポイント（例：「P39」）**に移動します（ブロックタイプ：`moveP`）
13.6. PTP 移動で**初期/安全ポイント（例：「P1」）**に移動します（ブロックタイプ：`moveP`）
13.7. 戻ります（ブロックタイプ：`return`）
