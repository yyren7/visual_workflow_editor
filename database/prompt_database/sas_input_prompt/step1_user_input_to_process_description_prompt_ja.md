# ロボットプロセス生成プロンプト - ステージ 1：ユーザー入力から詳細プロセス記述へ

## 目的

このプロンプトは、ユーザーが提供するロボットタスク記述（通常は自然言語の Markdown 形式）に基づいて、詳細なプロセス計画を生成することを目的としています。この計画には、メインプロセスと複数のサブプロセスの明確な記述、およびそれぞれのプロセスステップとコアロジックのテキスト説明が含まれている必要があります。目標は、ロボットタスク実行のための構造化された理解しやすい青写真を作成し、ユーザーレビューと後続の改良ステップの基礎として機能することです。

## 入力

1.  **ロボットタスク記述（.md またはテキスト）**：ロボットが完了することが期待される全体的なタスク、サブタスク、および操作対象に関する自然言語の記述が含まれています。

## 生成ガイドラインと要件

### 0. ロボット制御ブロックのコンプライアンス (最重要要件)

**必須ブロックマッピング**: プロセス記述の各ステップは、利用可能なロボット制御ブロックに厳密に対応しなければなりません。利用可能なブロックとその機能は提供されます。

- **ブロックタイプマッピング**: 記述する各ステップについて、それを 1 つ以上の特定のロボット制御ブロック（例：`moveP`、`set_motor`、`wait_input`、`procedures_callnoreturn` など）にマッピングできなければなりません。
- **機能制限**: 提供されたロボット制御ブロックで実現できない機能は記述しないでください。
- **注意事項の遵守**: 各ブロックタイプに記載されている注意事項と制限に厳密に従ってください。
- **依存関係の要件**: 適切な順序と依存関係を確認してください（例：「ロボット選択」は移動コマンドの前に、「モーター設定」は移動操作の前に必要です）。
- **ブロックタイプリファレンス**: 各ステップを記述する際に、その実装に使用するブロックタイプを明示的に記述してください。

**ブロック参照付きのステップ例**：

- 説明：「ロボットが初期/安全ポイント（例：'P_Home'）に移動します」
- ブロックタイプ：`moveP` または `moveL`
- 注意事項：最初に「ロボット選択」でロボットを定義し、使用前に「モーター設定」でサーボ電源をオンにする必要があります。

### 1. サブプログラム/機能の設計と定義（論理レベル）

- **コア機能モジュールの特定**：タスク記述から主要な操作と論理ユニットを抽出し、サブプログラムの候補を考案します。
- **サブプログラム名と略語の設計**：サブプログラム名内の略語（例：`BRG`、`PLT`、`CNV`、`RMC`、`LMC`、`BH`、`Crump`）に特に注意を払い、簡潔で機能を反映していることを確認します。サブプログラム名は、その目的を明確に表現する必要があります。
- **サブプログラム機能の明確化**：各サブプログラムが実行すべき特定のタスク、操作対象、および期待される結果を詳細に記述します。例：取得、配置、ベアリング、パレット、コンベア、加工ユニット、クランプ操作など。
- **アクションタイプの明確化**：サブプログラムの記述において、`Get`（取得/ピック）や`Put`（配置/置く）などの一般的なアクションを明確に区別します。
- **ペア操作の設計**：`Open_..._Clamp`と`Close_..._Clamp`など、論理的にペアとなるサブプログラムの設計に注意を払い、その機能を明確にします。

### 2. サブプログラムのモジュール化と再利用戦略計画（論理レベル）

- **標準操作シーケンスの再利用計画**：複数のサブプログラムで再利用できる標準操作シーケンスのロジックを特定し、記述します。例：
  - 材料把持/配置プロセス：「ターゲットに接近 -> 正確な位置決め -> アクション実行（例：把持/解放）-> ターゲットから離脱 -> 安全な位置に戻る」という一般的なロジックを記述します。
  - クランプ操作のカプセル化：クランプ制御ロジックがどのようにカプセル化され、さまざまな材料処理操作で呼び出されるかを記述します。
- **モジュラーデザイン**：クランプ制御、モーション制御などを、独立した再利用可能な論理モジュールとして記述すべきかどうかを計画します。
- **パラメータ化と構成に関する考慮事項**：柔軟性を高めるために、サブプログラムの動作を調整するために変数またはパラメータ（速度、力など）が必要かどうかを記述に含めます。
- **ネストされた呼び出し関係**：タスクを合理的に分解および結合するために、サブプログラム間の論理的な呼び出し関係を計画し、記述します。
- **対称/対応操作**：機能的に補完的または対応するサブプログラムペアのロジックを設計します。

### 3. メインプログラムコアロジックの構築（論理レベル）

- **メインプログラム初期化ステップの計画**：メインプログラムの開始時に通常実行される初期化ロジック（例：ロボットモデルの選択、モーターの起動、主要変数の初期化など）を記述します。
- **メインプログラム制御フローの設計**：メインループ、条件判断などの存在など、メインプログラムのマクロ制御フローを記述します。
- **メインプログラムのサブプログラム呼び出しシーケンスの編成**：メインプログラムがサブプログラムを順次呼び出すことによって全体的なタスクをどのように完了するかを計画し、記述し、各サブプログラム呼び出しのタイミングと目的を明確に説明します。
- **状態遷移と同期ロジックの考慮**：プログラムが特定の条件（例：センサー信号、外部 IO）を待機したり、信号を送信したりすることによって、外部環境または他のデバイスとどのように同期および対話するかのロジックを記述します。
- **安全性と移行ロジックの考慮**：ロボットがさまざまなタスクステージ間で特定の安全ポイントまたは移行ポイントに移動する必要があるかどうかに注意してください。
- **エラー処理とオプションパスロジックの考慮**：代替パスまたはエラー処理メカニズムが必要かどうかを検討し、記述します。一時的に有効になっていないが将来必要になる可能性のある機能については、そのロジックを記述し、オプションとしてマークすることができます。
- **終了と復帰ロジックの定義**：メインプログラムと各サブプログラムを終了する方法と条件を明確に定義します。

要約すると、ユーザーの自然言語タスク記述を、メインプロセスと各サブプロセスの責任、コアステップロジック、およびそれらの間の連携関係を明確に定義する、詳細で構造化されたドキュメントに変換する必要があります。この記述は、ユーザーの確認と変更のための視覚的な計画として機能します。

## Fewshot の例

### タスク入力の例（元のユーザー記述）

[ロボットタスク記述：この自動化プロセスは、ベアリング（BRG）、ベアリングハウジング（BH）、およびパレット（PLT）が関与する組み立ておよび取り扱いタスクを共同で完了することを目的としています。ロボットはまず、材料ラックまたは初期位置からベアリングとベアリングハウジングを取得します。その後、これら 2 つの部品を右側のマシニングセンター（RMC）に順次配置し、ここで圧入または組み立て操作を行うと推定されます。組み立て後、ロボットは RMC から組み立てられた部品を取り出し、左側のマシニングセンター（LMC）に転送して一時保管または後続処理を行います。次に、ロボットは空のパレットを取得し、このパレットをコンベア（CNV）の指定されたステーションに配置します。最後に、ロボットは LMC から以前に保管されていた組み立て済み部品を取得し、コンベア上のパレットに正確に配置して、サイクル全体を完了します。]

### 出力の例（詳細プロセス記述計画）

I. メインプログラムプロセス記述

    - ロボットモデルを選択します（例：「dobot_mg400」）。(ブロックタイプ: `select_robot`)
    - ロボットモーターを起動します。(ブロックタイプ: `set_motor`)
    - 必要なプロセス制御変数を初期化します（例：`start_condition = 2`）。(ブロックタイプ: `set_number`)
    - ロボットは**初期/安全ポイント（例：「P_Home」）**に移動します。(ブロックタイプ: `moveP`)
    - メインループ開始。(ブロックタイプ: `loop`)
    - 条件を確認：`start_condition = 2`（または連続操作のための無限ループ）。(ブロックタイプ: `controls_if`)
    - **（オプション/無効ロジック）**外部開始信号を待ちます（例：外部 IO 入力 `Start_Signal_IN`）。(ブロックタイプ: `wait_external_io_input`)
    - サブプログラム `BRG_Get_BRG`（ベアリング取得）を呼び出します。(ブロックタイプ: `procedures_callnoreturn`)
    - サブプログラム `Get_BH_InitialPos`（初期位置からベアリングハウジング取得）を呼び出します。(ブロックタイプ: `procedures_callnoreturn`)
    - ロボットは**初期/安全ポイント（例：「P_Home」）**に移動します。(ブロックタイプ: `moveP`)
    - マシニングセンター（RMC）の準備ができている信号（`RMC_Ready_IN`）を待ちます。(ブロックタイプ: `wait_external_io_input` または `wait_input`)
    - サブプログラム `RMC_Put_BH&BRG`（ベアリングハウジングとベアリングを RMC に配置）を呼び出します。(ブロックタイプ: `procedures_callnoreturn`)
    - RMC 加工完了信号（`RMC_Done_IN`）を待ちます。(ブロックタイプ: `wait_external_io_input` または `wait_input`)
    - 部品が取り出されたか、取り出す準備ができたことを RMC に通知する信号（`RMC_PartTaken_OUT`）を送信します。(ブロックタイプ: `set_external_io_output_upon` または `set_output`)
    - RMC 確認信号（`RMC_Confirm_IN`）を待ちます。(ブロックタイプ: `wait_external_io_input` または `wait_input`)
    - サブプログラム `RMC_Get_BH_Assembled`（RMC から組み立て済み部品取得）を呼び出します。(ブロックタイプ: `procedures_callnoreturn`)
    - ロボットは**初期/安全ポイント（例：「P_Home」）**に移動します。(ブロックタイプ: `moveP`)
    - サブプログラム `LMC_Put_BH_Temp`（部品を LMC に一時保管）を呼び出します。(ブロックタイプ: `procedures_callnoreturn`)
    - ロボットは**初期/安全ポイント（例：「P_Home」）**に移動します。(ブロックタイプ: `moveP`)
    - サブプログラム `CNV_Get_PLT`（コンベアからパレット取得）を呼び出します。(ブロックタイプ: `procedures_callnoreturn`)
    - サブプログラム `CNV_Put_PLT`（パレットをコンベアに配置）を呼び出します。(ブロックタイプ: `procedures_callnoreturn`)
    - ロボットは**初期/安全ポイント（例：「P_Home」）**に移動します。(ブロックタイプ: `moveP`)
    - サブプログラム `LMC_Get_BH_Stored`（LMC から保管部品取得）を呼び出します。(ブロックタイプ: `procedures_callnoreturn`)
    - ロボットは**初期/安全ポイント（例：「P_Home」）**に移動します。(ブロックタイプ: `moveP`)
    - サブプログラム `CNV_Put_BH_On_PLT`（部品をコンベアのパレットに配置）を呼び出します。(ブロックタイプ: `procedures_callnoreturn`)
    - **（オプション/無効ロジック）**タスク完了信号を外部システムに送信します（`Task_Complete_OUT`）。(ブロックタイプ: `set_external_io_output_upon` または `set_output`)
    - ループの開始に戻ります。(ブロックタイプ: `return`)

II. サブプログラムとその機能記述

1.  **`BRG_Get_BRG`（ベアリング取得）**：

    - 機能：ロボットは指定された初期位置（例：材料ラック）からベアリングを取得します。
    - 関与するクランプ：`BRG&PLT_Clamp`（ベアリングとパレットを操作するためのクランプ）。
    - コアロジック：
      - ベアリングピックアップ待機ポイントに移動（例：「P21」）。(ブロックタイプ: `moveP`)
      - ピックアップのためにベアリングの上に移動（例：「P22」）。(ブロックタイプ: `moveP`)
      - サブプログラム Open_BRG&PLT_Clamp を呼び出します。(ブロックタイプ: `procedures_callnoreturn`)
      - ベアリング精密把持ポイントに下降（例：「P23」）。(ブロックタイプ: `moveP`)
      - サブプログラム Close_BRG&PLT_Clamp を呼び出します。(ブロックタイプ: `procedures_callnoreturn`)
      - ベアリングを持って上昇（例：「P25」）。(ブロックタイプ: `moveP`)
      - ベアリングピックアップ出発ポイントに移動（例：「P26」）。(ブロックタイプ: `moveP`)
      - ベアリングピックアップ待機ポイントに戻ります（例：「P21」）。(ブロックタイプ: `moveP`)

2.  **`Get_BH_InitialPos`（初期位置からベアリングハウジング取得）**：（flow.xml の `CNV_Get_BH` に対応）

    - 機能：ロボットは指定された初期位置からベアリングハウジングを取得します。
    - 関与するクランプ：`BH_Clamp`（ベアリングハウジングを操作するためのクランプ）。
    - コアロジック：
      - ベアリングハウジングピックアップ待機ポイントに移動（例：「P31」）。(ブロックタイプ: `moveP`)
      - ピックアップのためにベアリングハウジングの上に移動（例：「P32」）。(ブロックタイプ: `moveP`)
      - サブプログラム Open_BH_Clamp を呼び出します。(ブロックタイプ: `procedures_callnoreturn`)
      - ベアリングハウジング精密把持ポイントに下降（例：「P33」）。(ブロックタイプ: `moveP`)
      - サブプログラム Close_BH_Clamp を呼び出します。(ブロックタイプ: `procedures_callnoreturn`)
      - ベアリングハウジングを持って上昇（例：「P32」）。(ブロックタイプ: `moveP`)
      - ベアリングハウジングピックアップ待機ポイントに戻ります（例：「P31」）。(ブロックタイプ: `moveP`)

3.  **`RMC_Put_BH&BRG`（ベアリングハウジングとベアリングを右マシニングセンターに配置）**：

    - 機能：ロボットは以前に取得したベアリングハウジングとベアリングを右マシニングセンター（RMC）の指定されたステーションに順次配置します。
    - 関与するクランプ：`BH_Clamp`、`BRG&PLT_Clamp`。
    - コアロジック：
      - RMC 移行/移動ポイント（例：「P20」）。(ブロックタイプ: `moveP`)
      - BH 配置のための RMC 待機ポイントに移動（例：「P11」）。(ブロックタイプ: `moveP`)
      - RMC 中間/転送ポイント（例：「P12」）。(ブロックタイプ: `moveP`)
      - RMC BH インタラクション/アクセスポイント（例：「P14」）。(ブロックタイプ: `moveP`)
      - RMC BH 把持/解放ポイント（例：「P15」）。(ブロックタイプ: `moveP`)
      - サブプログラム Open_BH_Clamp を呼び出します。(ブロックタイプ: `procedures_callnoreturn`)
      - 速度を 10 に設定。(ブロックタイプ: `set_speed`)
      - RMC BH インタラクション/アクセスポイント（例：「P14」）。(ブロックタイプ: `moveP`)
      - 速度を 100 に設定。(ブロックタイプ: `set_speed`)
      - BRG 配置のための RMC 待機ポイントに移動（例：「P13」）。(ブロックタイプ: `moveP`)
      - RMC BRG ホバー/アクセスポイント（例：「P16」）。(ブロックタイプ: `moveP`)
      - RMC BRG 精密配置ポイントに移動（例：「P17」）。(ブロックタイプ: `moveP`)
      - サブプログラム Open_BRG&PLT_Clamp を呼び出します。(ブロックタイプ: `procedures_callnoreturn`)
      - 速度を 10 に設定。(ブロックタイプ: `set_speed`)
      - RMC BRG ホバー/アクセスポイント（例：「P16」）。(ブロックタイプ: `moveP`)
      - 速度を 100 に設定。(ブロックタイプ: `set_speed`)
      - RMC 中間/転送ポイント（例：「P12」）。(ブロックタイプ: `moveP`)
      - RMC 出発/待機ポイントに移動（例：「P11」）。(ブロックタイプ: `moveP`)

4.  **`RMC_Get_BH_Assembled`（右マシニングセンターから組み立て済み部品取得）**：（flow.xml の `RMC_Get_BH` に対応）

    - 機能：ロボットは右マシニングセンター（RMC）から組み立て済み（または処理済み）のベアリングハウジングを取得します。
    - 関与するクランプ：`BH_Clamp`。
    - コアロジック：
      - 組み立て済み部品ピックアップのための RMC 待機ポイントに移動（例：「P11」）。(ブロックタイプ: `moveP`)
      - RMC 中間/転送ポイント（例：「P12」）。(ブロックタイプ: `moveP`)
      - RMC BH インタラクション/アクセスポイント（例：「P14」）。(ブロックタイプ: `moveP`)
      - RMC BH 把持/解放ポイント（例：「P15」）。(ブロックタイプ: `moveP`)
      - サブプログラム Close_BH_Clamp を呼び出します。(ブロックタイプ: `procedures_callnoreturn`)
      - RMC BH インタラクション/アクセスポイント（例：「P14」）。(ブロックタイプ: `moveP`)
      - RMC 中間/転送ポイント（例：「P12」）。(ブロックタイプ: `moveP`)
      - 部品を持って RMC 出発ポイントに移動（例：「P11」）。(ブロックタイプ: `moveP`)
      - RMC 移行/移動ポイント（例：「P20」）。(ブロックタイプ: `moveP`)

5.  **`LMC_Put_BH_Temp`（部品を左マシニングセンターに一時保管）**：（flow.xml の `LMC_Put_BH` に対応）

    - 機能：ロボットは RMC から取得した部品を左マシニングセンター（LMC）に配置して、一時保管または後続処理を行います。
    - 関与するクランプ：`BH_Clamp`。
    - コアロジック：
      - LMC 転送/待機ポイント（例：「P41」）。(ブロックタイプ: `moveP`)
      - LMC ホバー/アクセスポイント（例：「P42」）。(ブロックタイプ: `moveP`)
      - LMC 把持/解放ポイント（例：「P43」）。(ブロックタイプ: `moveP`)
      - サブプログラム Open_BH_Clamp を呼び出します。(ブロックタイプ: `procedures_callnoreturn`)
      - LMC ホバー/アクセスポイント（例：「P42」）。(ブロックタイプ: `moveP`)
      - LMC 転送/待機ポイント（例：「P41」）。(ブロックタイプ: `moveP`)
      - メインの安全/初期ポイントに戻ります（例：「P1」）。(ブロックタイプ: `moveP`)

6.  **`CNV_Get_PLT`（コンベアからパレット取得）**：

    - 機能：ロボットは指定された場所（おそらくコンベアの別の領域）から空のパレットを取得します。
    - 関与するクランプ：`BRG&PLT_Clamp`。
    - コアロジック：
      - パレット処理待機ポイント（例：「P34」）。(ブロックタイプ: `moveP`)
      - パレットピックアップホバー/上昇ポイント（例：「P35」）。(ブロックタイプ: `moveP`)
      - 速度を 10 に設定。(ブロックタイプ: `set_speed`)
      - パレット精密把持ポイントに下降（例：「P36」）。(ブロックタイプ: `moveP`)
      - サブプログラム Close_BRG&PLT_Clamp を呼び出します。(ブロックタイプ: `procedures_callnoreturn`)
      - パレットピックアップホバー/上昇ポイント（例：「P35」）。(ブロックタイプ: `moveP`)
      - 速度を 100 に設定。(ブロックタイプ: `set_speed`)
      - パレット処理待機ポイント（例：「P34」）。(ブロックタイプ: `moveP`)

7.  **`CNV_Put_PLT`（パレットをコンベアに配置）**：

    - 機能：ロボットは取得した空のパレットをコンベアの指定されたステーションに配置します。
    - 関与するクランプ：`BRG&PLT_Clamp`。
    - コアロジック：
      - CNV パレット配置ホバー/上昇ポイント（例：「P37」）。(ブロックタイプ: `moveP`)
      - コンベア上のパレット精密配置ポイントに移動（例：「P38」）。(ブロックタイプ: `moveP`)
      - サブプログラム Open_BRG&PLT_Clamp を呼び出します。(ブロックタイプ: `procedures_callnoreturn`)
      - CNV パレット配置ホバー/上昇ポイント（例：「P37」）。(ブロックタイプ: `moveP`)
      - パレット処理待機ポイント（例：「P34」）。(ブロックタイプ: `moveP`)

8.  **`LMC_Get_BH_Stored`（左マシニングセンターから保管部品取得）**：（flow.xml の `LMC_Get_BH` に対応）

    - 機能：ロボットは左マシニングセンター（LMC）から以前に保管されていた部品を取得します。
    - 関与するクランプ：`BH_Clamp`。
    - コアロジック：
      - LMC 転送/待機ポイント（例：「P41」）。(ブロックタイプ: `moveP`)
      - LMC ホバー/アクセスポイント（例：「P42」）。(ブロックタイプ: `moveP`)
      - LMC 把持/解放ポイント（例：「P43」）。(ブロックタイプ: `moveP`)
      - サブプログラム Close_BH_Clamp を呼び出します。(ブロックタイプ: `procedures_callnoreturn`)
      - LMC ホバー/アクセスポイント（例：「P42」）。(ブロックタイプ: `moveP`)
      - LMC 転送/待機ポイント（例：「P41」）。(ブロックタイプ: `moveP`)

9.  **`CNV_Put_BH_On_PLT`（部品をコンベアのパレットに配置）**：（flow.xml の `CNV_Put_BH` に対応）

    - 機能：ロボットは LMC から取得した部品を、コンベア上の事前に配置されたパレットに正確に配置します。
    - 関与するクランプ：`BH_Clamp`。
    - コアロジック：
      - CNV 部品オンパレットホバー/上昇ポイント（例：「P39」）。(ブロックタイプ: `moveP`)
      - パレット上の部品精密配置ポイントに移動（例：「P40」）。(ブロックタイプ: `moveP`)
      - サブプログラム Open_BH_Clamp を呼び出します。(ブロックタイプ: `procedures_callnoreturn`)
      - CNV 部品オンパレットホバー/上昇ポイント（例：「P39」）。(ブロックタイプ: `moveP`)
      - メインの安全/初期ポイントに戻ります（例：「P1」）。(ブロックタイプ: `moveP`)
      - サブプログラムから戻ります。(ブロックタイプ: `return`)

10. **`Open_BH_Clamp`（ベアリングハウジングクランプを開く）**：

    - 機能：ロボットのエンドエフェクタを制御して、ベアリングハウジングを保持するために使用されるクランプを開きます。
    - コアロジック：
      - クランプ操作のための所定の遅延を待ちます（例：タイマー「N483」）。(ブロックタイプ: `wait_timer`)
      - ベアリングハウジングクランプを開く信号を送信します（例：出力ピン 1 をオンに設定）。(ブロックタイプ: `set_output`)
      - ベアリングハウジングクランプが開いていることを確認するフィードバックを待ちます（例：入力ピン 0 がオンになるのを待ちます）。(ブロックタイプ: `wait_input`)

11. **`Close_BH_Clamp`（ベアリングハウジングクランプを閉じる）**：

    - 機能：ロボットのエンドエフェクタを制御して、ベアリングハウジングを保持するために使用されるクランプを閉じます。
    - コアロジック：
      - クランプ操作のための所定の遅延を待ちます（例：タイマー「N482」）。(ブロックタイプ: `wait_timer`)
      - ベアリングハウジングクランプを閉じる信号を送信します（例：出力ピン 1 をオフに設定）。(ブロックタイプ: `set_output`)
      - ベアリングハウジングクランプが閉じていることを確認するフィードバックを待ちます（例：入力ピン 1 がオンになるのを待ちます）。(ブロックタイプ: `wait_input`)

12. **`Open_BRG&PLT_Clamp`（ベアリング/パレットクランプを開く）**：

    - 機能：ロボットのエンドエフェクタを制御して、ベアリングまたはパレットを保持するために使用されるクランプを開きます。
    - コアロジック：
      - クランプ操作のための所定の遅延を待ちます（例：タイマー「N482」）。(ブロックタイプ: `wait_timer`)
      - ベアリング/パレットクランプを開く信号を送信します（例：出力ピン 2 をオンに設定）。(ブロックタイプ: `set_output`)
      - ベアリング/パレットクランプが開いていることを確認するフィードバックを待ちます（例：入力ピン 2 がオンになるのを待ちます）。(ブロックタイプ: `wait_input`)

13. **`Close_BRG&PLT_Clamp`（ベアリング/パレットクランプを閉じる）**：
    - 機能：ロボットのエンドエフェクタを制御して、ベアリングまたはパレットを保持するために使用されるクランプを閉じます。
    - コアロジック：
      - クランプ操作のための所定の遅延を待ちます（例：タイマー「N482」）。(ブロックタイプ: `wait_timer`)
      - ベアリング/パレットクランプを閉じる信号を送信します（例：出力ピン 2 をオフに設定）。(ブロックタイプ: `set_output`)
      - ベアリング/パレットクランプが閉じていることを確認するフィードバックを待ちます（例：入力ピン 3 がオンになるのを待ちます）。(ブロックタイプ: `wait_input`)

III. モジュール化と再利用の説明

- **クランプ操作**：`Open/Close_BH_Clamp` および `Open/Close_BRG&PLT_Clamp` は、独立した再利用可能なサブプログラムとして設計されています。これらは各クランプタイプの特定の制御ロジックをカプセル化し、さまざまな材料処理サブプログラム（`BRG_Get_BRG`、`Get_BH_InitialPos`、`RMC_Put_BH&BRG` など）によって呼び出されます。これにより、一貫性が促進され、メンテナンスが簡素化されます。
- **標準移動シーケンス**：ほとんどのピックアンドプレースサブプログラム（`BRG_Get_BRG`、`Get_BH_InitialPos`、`CNV_Get_PLT` など）は、一般的な「ターゲットに接近 -> 正確な位置決め -> アクション実行（把持/解放）-> ターゲットから離脱 -> 安全な位置に戻る」移動パターンに従います。このロジックは抽象化して再利用でき、さまざまなターゲットロケーションに対してパラメータ化された関数を介して可能性があります。
- **速度制御**：高精度またはデリケートな取り扱いが必要な操作（例：`RMC_Put_BH&BRG`、`CNV_Get_PLT`）の場合、コアロジックは重要なフェーズ中に速度を落とす必要性を明示的に言及しています。これは、パラメータまたは専用の低速移動関数を介して実装できます。
- **外部インタラクションと同期**：メインプロセスには、外部デバイス（RMC、LMC、コンベア）との同期のための複数のポイントが組み込まれています。これは、特定の入力信号（`RMC_Ready_IN`、`RMC_Done_IN`）を待機し、出力信号（`RMC_PartTaken_OUT`、`Task_Complete_OUT`）を送信することによって実現されます。このモジュラーアプローチにより、周囲の環境との堅牢なインタラクションが保証されます。
- **オプションロジック**：外部開始信号の待機やタスク完了信号の送信などの機能はオプションとしてマークされています。これにより、特定のシステム統合要件に基づいてこれらの機能を有効または無効にできる柔軟な展開が可能になり、コアプロセスフローを変更する必要はありません。
